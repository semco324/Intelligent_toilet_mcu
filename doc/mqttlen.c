
#include <stdio.h>
#include <string.h>

/*
[in] msglen 要编码的长度
[out] arr_buf编码后首地址
[out] arr_len编码后可变长度所占用字节数1~4
*/
int mqttmsglen_to_arr(int msglen,unsigned char * arr_buf,char * arr_len)
{
   char i=0;
	do{
		arr_buf[i] = msglen % 128;
		msglen /= 128;
	    if(msglen > 0)
			arr_buf[i] |=0x80;
		i++;
	}while(msglen > 0 );
	
	* (arr_len) = i;
	if( i>4 ) 
		return -1;

    return 0;
}

/*
[in] arr_buf编码后首地址
[out] arr_len编码后可变长度所占用字节数1~4
[out] msglen编码的长度
*/
int mqttarr_to_len(unsigned char * arr_buf,unsigned char *arr_len,int *msglen)
{
   unsigned char i=0;
   *arr_len = 0;
   
   for(i=0;i<4;i++)
   {
     if( (arr_buf[i] & 0x80) == 0x80)
	 	(*arr_len)++; //bit7==1
	 else 
	 	break;
   }
   (*arr_len)++;
   if((*arr_len) > 4) (*arr_len) = 4;
	   
   if(i > 4)
   {
     return -1;
   }

   int mul=1;
   i=0;
   *msglen = 0;
   do{
	 *msglen += (arr_buf[i] & 0x7F) * mul;
	 mul = mul * 128;
   }while( (arr_buf[i++] & 0x80) != 0 );

   return 0;
}


/*
typedef uint32 unsigned int;
typedef uint16 unsigned short int;
typedef uint8 unsigned char;*/

const char crc16_tab_h[] = {
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40 }; 

const char crc16_tab_l[] = {
0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40 };  

/** 
 * CRC16 
 * @param data    需要计算的数组 
 * @param offset  起始位置 
 * @param len     长度 
 * @param preval  之前的校验值 
 * @return CRC16  校验值 
 */  
short int calcCrc16(char *data, int offset, int len, int preval)
{
    int ucCRCHi = (preval & 0xff00) >> 8;  
    int ucCRCLo =  preval & 0x00ff;  
    int iIndex;  
    int i;
    for (i = 0; i < len; ++i) {  
        iIndex = (ucCRCLo ^ data[offset + i]) & 0x00ff;  
        ucCRCLo = ucCRCHi ^ crc16_tab_h[iIndex];  
        ucCRCHi = crc16_tab_l[iIndex];  
    }  
    return ((ucCRCHi & 0x00ff) << 8) | (ucCRCLo & 0x00ff) & 0xffff;  
}

int getCrcData(char *msgbuf,int msgbufLen)
{
	return calcCrc16(msgbuf, 0, msgbufLen, 0xffff);  
}

int checkCRC(char *msgbuf,int msgbufLen)
{
	int getCrc = getCrcData(msgbuf+2,msgbufLen-6);//计算CRC时，不包含数据头部和CRC本身
	int receiveCrc = ((msgbuf[msgbufLen-4] << 24) | (msgbuf[msgbufLen-3] << 16) | (msgbuf[msgbufLen-2] << 8) | (msgbuf[msgbufLen-1]));
	if(getCrc == receiveCrc){
		return 1;
	}
	else{
		printf("%s(%d) %d, %d\r\n",__func__,__LINE__,getCrc,receiveCrc);
		return 0;
	}
}




int BuildMqttSendMsg(unsigned char *inbuf,int *inbuf_len,unsigned char *outbuf,int *outbuf_len)
{
	int outbuf_len_tmp = 0;
    char i;
    int crcData= 0;
	//frame header
	outbuf[outbuf_len_tmp++] = (0x55AA>>8)&0xFF;
	outbuf[outbuf_len_tmp++] = (0x55AA)&0xFF;

	//可变长度 flag(1) cmd(2) 
	mqttmsglen_to_arr(1 + 2 + *inbuf_len ,&outbuf[outbuf_len_tmp],&i);

    outbuf_len_tmp += i;
	
	outbuf[outbuf_len_tmp++] = 0x00; //flag

	outbuf[outbuf_len_tmp++] = (0x0091>>8)&0xFF;

	outbuf[outbuf_len_tmp++] = 0x0091&0xFF;

	memcpy(&outbuf[outbuf_len_tmp],inbuf,*inbuf_len);

	outbuf_len_tmp += *inbuf_len;

    //CRC
	crcData = getCrcData(outbuf+2,outbuf_len_tmp-2);
	outbuf[outbuf_len_tmp++] = (crcData>>24)&0xFF;
	outbuf[outbuf_len_tmp++] = (crcData>>16)&0xFF;
	outbuf[outbuf_len_tmp++] = (crcData>>8)&0xFF;
	outbuf[outbuf_len_tmp++] = (crcData)&0xFF;

	*outbuf_len = outbuf_len_tmp;
	
	return 0;
}



/*
[in] inbuf待解析buff首地址
[in] 待解析inbuff长度
[out] outbuf 解析后输出首地址
[out] outbuf_len 解析后长度
return -1 消息错误
return 0 消息正确
*/
#define SUB_PACKAGE_HEADER 0x55AA
int DecodeMqttRecvMsg(unsigned char *inbuf,int *inbuf_len,unsigned char *outbuf,int *outbuf_len)
{
    int msg_len_tmp=0;
    char flag;
    //head
    if(inbuf[msg_len_tmp++] != (SUB_PACKAGE_HEADER>>8)&0xff)
	{
		printf("SUB_PACKAGE_HEADER_1\n");
		return -1;
	}
    if(inbuf[msg_len_tmp++] != ((SUB_PACKAGE_HEADER)&0xff))
	{
		printf("SUB_PACKAGE_HEADER_2\n");
		return -1;	
	}
	
    unsigned char len_byte;//可变长度编码所占字节数
	int msg_len;//消息字节数

	//可变长度
	if( mqttarr_to_len(&inbuf[2],&len_byte,&msg_len) <0)
	{
		printf("mqttarr_to_len\n");
		return -1;
	}

	if(checkCRC(inbuf, msg_len + len_byte + 6) == 0)
	{
	   printf("checkCRC\n");
       return -1;
	}
	
	msg_len_tmp +=len_byte;//跳过可变长度

	flag = inbuf[msg_len_tmp++];//flag

    //命令字0x0090
	if(inbuf[msg_len_tmp++] != (0x0090>>8)&0xff)
		//return -1;
		{;}
	if(inbuf[msg_len_tmp++] != (0x0090)&0xff)
		//return -1;
		{;}

	*outbuf_len = msg_len-3;
	memcpy(outbuf, &inbuf[msg_len_tmp], *outbuf_len);
}


int main(void)
{
    /*unsigned char arr[30]={0};
	char arr_len;
	char i;
    printf("mqttmsglen_to_arr:%d\n",mqttmsglen_to_arr(268435455,arr,&arr_len));
	for(i=0;i<30;i++)
		printf("0x%02x ",arr[i]);
	printf("\n");
	printf("%d\n",arr_len);	
	printf("\n");
	int msglen;
	printf("mqttarr_to_len %d\n",mqttarr_to_len(arr,&arr_len,&msglen));
    printf("%d\n",msglen);
	printf("%d\n",arr_len);
	printf("\n");*/
	char i;
	unsigned char arr[30]={0};
	for(i=0;i<30;i++)
	{
		arr[i]=i;
	}
	int len = sizeof(arr);
	unsigned char mqtt_arr[60]={0};
	int mqtt_len=0;
	BuildMqttSendMsg(arr,&len,mqtt_arr,&mqtt_len);
	
    for(i=0;i<mqtt_len;i++)
	{
		printf("%02x ",mqtt_arr[i]);
	}
	printf("\n");
	printf("%d\n",mqtt_len);
	
	int inbuf_len = strlen(mqtt_arr);
	unsigned char outbuf[50];
	int outbuf_len;
	DecodeMqttRecvMsg(mqtt_arr,&inbuf_len,outbuf,&outbuf_len);
	
    for(i=0;i<outbuf_len;i++)
	{
		printf("%02x ",outbuf[i]);
	}
	printf("\n");
	printf("%d\n",outbuf_len);
	
	printf("\n");
	unsigned char app_clientid[20]={0};
	char* sp=NULL;
	sp = strchr( strchr("app2dev/12345678902/",'/')+1, '/');
	memset(app_clientid, 0, sizeof(app_clientid));
	memcpy(app_clientid,sp+1,strlen(sp+1)>20?20:strlen(sp+1));	
	printf("%s\n",app_clientid);
	return 0;
}

